#!/usr/bin/env node

const FS = require('fs');

function die( message ) {
    console.log( 'ERROR: ' + message );
    process.exit( -1 );
}

var parsers = {};

function dispatch( rule, name, schema ) {
    schema = include(schema);

    if (schema.type.constructor === Array) {
        [type, default_value] = schema.type;
    } else {
        [type, default_value] = [schema.type, null];
    }

    let parser = parsers[type];
    if ( parser == null ) {
        die( 'No parser found for ' + name + ' : ' + schema.type );
    }
    parser( rule, name, schema );
}

/*
 * extract part of the schema
 */
function extract( schema, segments ) {
    if ( segments.length == 0 ) return schema;
    let segment = segments.shift();
    return extract( schema[segment], segments );
}

function include( schema ) {
    // Should check for undefined
    if ( schema["$ref"] == null ) return schema;
    let [file, path] = schema["$ref"].split('#');
    let segments = path.split('/');
    segments.shift(); // remove empty root
    let content = JSON.parse( FS.readFileSync(file, 'utf8') );
    let snippet = extract( content, segments );
    return snippet;
}

function qstring( name ) {
    return '"\\"' + name + '\\"" ';
}

function keystring( name ) {
    if ( name == null ) return '';
    return qstring(name) + '":" ';
}

function basic_type( rule, name, type ) {
    console.log( rule + ': ' + keystring(name) + ' ' + type + ' ;' );
}

parsers["number"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Number' );
};

parsers["integer"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Integer' );
};

parsers["boolean"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Boolean' );
};

/*
 * Need to handle "default" slot also
 */
parsers["string"] = function ( rule, name, schema ) {
    if ( schema["enum"] == null ) {
        return basic_type( rule, name, 'StringLiteral' );
    }
    console.log( rule + ': ' + keystring(name) );
    let strings = schema["enum"].map( e => qstring(e) );
    console.log( "[ " + strings.join('|') + " ]" );
    console.log( ' ;' );
};

parsers["array"] = function ( rule, name, schema ) {
    // console.log( "/* " + schema.description + " */" );
    console.log( rule + ': ' + keystring(name) + ' "[" ' + name + '-items "]" ;' );
    console.log( name + '-items: ' +
                 name + '-item | ' +
                 name + '-items  "," ' + name + '-item ;' );

    schema.items = include(schema.items);
    console.log( '/* look up array parser for ' + schema.items.type + ' */' );

    dispatch( name + '-item', null, schema.items );
    // let parser = parsers[schema.items.type];
    // parser( name + '-item', schema.items );
};

parsers["object"] = function ( rule, name, schema ) {
    console.log( '/* parse object schema for ' + name + ' */' );
    let keys = Object.keys(schema.properties);
    console.log( rule + ': ' + keystring(name) + ' "{" ' + keys.join(' "," ') + ' "}" ;' );
    let p = schema.properties;
    keys.map( key => dispatch(key, key, p[key]) );
};

function parse( err, data ) {
    if ( err ) die( "failed to read file: " + err );
    console.log( '#include "base.pb"' );
    let dto = JSON.parse( data );
    dispatch( 'root', null, dto );
    // let parser = parsers[dto.type];
    // parser( 'root', dto );
}

FS.readFile( process.argv[2], parse );

/* vim: set autoindent expandtab sw=4 syntax=javascript : */
