#!/usr/bin/env node

const FS = require('fs');

function warning( message ) {
    console.error( 'WARNING: ' + message );
}

function die( message ) {
    console.error( 'ERROR: ' + message );
    process.exit( -1 );
}

var parsers = {};

function dispatch( rule, name, schema ) {
    schema = include(schema);

    if ( schema.type == null ) {
        die( 'schema "' + name + '" has no TYPE -- ' + JSON.stringify(schema) );
    }

    if ( schema.type.constructor === Array ) {
        [type, default_value] = schema.type;
    } else {
        [type, default_value] = [schema.type, null];
    }

    let parser = parsers[type];
    if ( parser == null ) {
        die( 'No parser found for ' + name + ' : ' + schema.type );
    }
    parser( rule, name, schema );
}

/*
 * extract part of the schema
 */
function extract( schema, segments ) {
    if ( segments.length == 0 ) return schema;
    let segment = segments.shift();
    return extract( schema[segment], segments );
}

function include( schema ) {
    // Should check for undefined
    if ( schema["$ref"] == null ) return schema;
    let [file, path] = schema["$ref"].split('#');
    // if the file is null - then we are referencing the current file
    console.error( "LOADING '" + file + "' path='" + path + "'" );

    let segments = path.split('/');
    segments.shift(); // remove empty root

    let content = JSON.parse( FS.readFileSync(file, 'utf8') );

    let snippet = extract( content, segments );
    if ( snippet["$ref"] == null ) return snippet;
    die( "DOUBLE INCLUDE" );
}

function qstring( name ) {
    return '"\\"' + name + '\\"" ';
}

function keystring( name ) {
    if ( name == null ) return '';
    return qstring(name) + '":" ';
}

function basic_type( rule, name, type ) {
    console.log( rule + ': ' + keystring(name) + ' ' + type + ' ;' );
}

parsers["number"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Number' );
};

parsers["integer"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Integer' );
};

parsers["boolean"] = function ( rule, name, schema ) {
    basic_type( rule, name, 'Boolean' );
};

/*
 * Need to handle "default" slot also
 */
parsers["string"] = function ( rule, name, schema ) {
    if ( schema["enum"] == null ) {
        return basic_type( rule, name, 'StringLiteral' );
    }
    console.log( rule + ': ' + keystring(name) );
    let strings = schema["enum"].map( e => qstring(e) );
    console.log( "[ " + strings.join('|') + " ]" );
    console.log( ' ;' );
};

parsers["array"] = function ( rule, name, schema ) {
    // console.log( "/* " + schema.description + " */" );
    console.log( rule + ': ' + keystring(name) + ' "[" ' + name + '-items "]" ;' );
    console.log( name + '-items: ' +
                 name + '-item | ' +
                 name + '-items  "," ' + name + '-item ;' );

    schema.items = include(schema.items);
    // console.log( '/* look up array parser for ' + schema.items.type + ' */' );

    dispatch( name + '-item', null, schema.items );
    // let parser = parsers[schema.items.type];
    // parser( name + '-item', schema.items );
};

parsers["object"] = function ( rule, name, schema ) {
    // console.log( '/* parse object schema for ' + name + ' */' );
    let keys = Object.keys(schema.properties);
    console.log( rule + ': ' + keystring(name) + ' "{" ' + keys.join(' "," ') + ' "}" ;' );
    let p = schema.properties;
    keys.map( key => dispatch(key, key, p[key]) );
};

function check_definitions( dto ) {
    if ( typeof dto["type"] == 'undefined' ) {
        if ( dto.definitions ) {
            console.error( "this is not a schema" );
            process.exit( 0 );
        }
        die( "Invalid schema - no top level type" );
    }
}

function resolve( dto, filename ) {
    if ( dto.constructor  !== Object ) return dto;
    if ( dto["$ref"] == null ) {
        let keys = Object.keys(dto);
        keys.map( key => dto[key] = resolve(dto[key], filename) );
        return dto;
    }
    let [file, path] = dto["$ref"].split('#');
    file = file || filename;
    let content = JSON.parse( FS.readFileSync(file, 'utf8') );
    let segments = path.split('/');
    segments.shift(); // remove empty root
    let snippet = extract( content, segments );
    return resolve( snippet, file );
}

function parse( err, data ) {
    if ( err ) die( "failed to read file: " + err );
    console.log( '#include "base.pb"' );
    let dto = resolve( JSON.parse(data) );
    check_definitions( dto );
    dispatch( 'root', null, dto );
}

FS.readFile( process.argv[2], parse );

/* vim: set autoindent expandtab sw=4 syntax=javascript : */
